{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to FICO","text":""},{"location":"#strategy","title":"Strategy","text":"<p>The PIN project estimates the Probability of Insider Trading for stocks and constructs portfolios based on these estimates.</p> <p>Modules exported by this package:</p> <p>pin_estimation: Provides Probability of Insider Trading estimates. portfolio_build: Facilitates portfolio construction. returns: Supports return calculations. stock_selection: Offers a selection of stocks.</p>"},{"location":"#project","title":"Project","text":"<p>Link to the strategy article</p>"},{"location":"#tearsheet","title":"Tearsheet","text":"<p>Link to Tear Sheet</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>I would like to express my heartfelt gratitude to professors Vitor Curtis, Elton Sbruzzi, Michel Leles, and Orleans Martins for their unwavering support throughout the development of this work. Their guidance, expertise, and encouragement have been invaluable, shaping the trajectory of my research journey. Their commitment to fostering academic growth and their dedication to providing insightful feedback have played a pivotal role in the successful completion of this project. I am truly fortunate to have had such dedicated mentors, and I am sincerely thankful for their contributions to my academic and professional development.</p>"},{"location":"#citations","title":"Citations","text":"<p>D. Easley and M. O\u2019hara. Price, trade size, and information in securities markets. Journal of Financial economics, 19(1):69\u201390, 1987.</p> <p>D. Easley and M. O\u2019hara. Time and the process of security price adjustment. The Journal of finance, 47(2):577\u2013605, 1992.</p> <p>D. Easley, N. M. Kiefer, M. O\u2019hara, and J. B. Paperman. Liquidity, information, and infrequently traded stocks. The Journal of Finance, 51(4):1405\u20131436, 1996.</p>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#objective","title":"Objective","text":"<p>Using the Probability of Insider Trading (PIN) estimates from Easley and O'Hara (1996) to construct long and short portfolios and generate a reasonable Sharpe ratio.</p>"},{"location":"explanation/#strategy","title":"Strategy","text":"<p>Asset Selection: The eligible assets for portfolio composition will be the stocks that meet the following asset filtering criteria:</p> <ul> <li>Higher Liquidity Criterion: To be the most traded stock of the company in the previous month.</li> <li>Daily Liquidity Criterion: To have an average daily trading volume of at least R$ 500,000 in the previous period.</li> <li>Listing Criterion: To be listed for at least 2 years from the observation moment.</li> </ul> <p>PIN estimation: For each stock selected, we create a moving window of 60 days in order to estimate the following indicators: - alpha = Probability of the occurrence of an informational event - delta = Conditional probability of an event with a positive signal - mu = Informed agents flux - eps_s = Uninformed agents selling flux - eps_b = Uninformed agents buying flux - PIN = Probability of informed trading occurence</p> <p>Sorting by Signal: Using the series of PIN models for eligible assets, two portfolios were constructed monthly: one for assets with positive informational events and another for assets with negative informational events. These assets were sorted by the probability 'delta' of presenting a positive signal, and the upper and lower quintiles were selected. The upper quintile formed the candidates for the positive portfolio, and the lower quintile formed the candidates for the negative portfolio.</p> <p>Sorting by PIN: Next, within each portfolio, a sorting was performed based on the PIN value, and the upper quartile of each was selected. Thus, two portfolios are constructed: one with assets having the highest PINs and the highest probabilities of events being positive (long portfolio), and another with assets having the highest PINs and the lowest probabilities of events being positive (short portfolio).</p> <p>Resulting Portfolio: With the assets from the two selected portfolios, the capital was allocated as follows:</p> <ul> <li>100% of the capital was allocated to the Treasury SELIC as collateral for leverage.</li> <li>100% of the capital was allocated to the long portfolio, distributed equally among the assets.</li> <li>100% of the capital was used to sell the short portfolio, distributed equally among the assets.</li> </ul>"},{"location":"how-to-guides/","title":"How-to Guides","text":""},{"location":"how-to-guides/#how-to-estimate-pins","title":"How To Estimate PINs?","text":"<p>Download the code from this GitHub repository and place the <code>fico/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 fico/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 strategy_simulator.py\n\u2502   \u251c\u2500\u2500 modules/\n\u2502   \u2514\u2500\u2500 data/\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>In data folder, add CSVs (each one for a stock) containing two columns: vendedor and comprador (seller and buyer). Then run </p> <pre><code>from fico.modules import pin_estimation\npin_estimation.estimate_all_pins()\n</code></pre>"},{"location":"how-to-guides/#how-to-select-stocks","title":"How To Select Stocks?","text":"<p>Run the following code</p> <pre><code>from fico.modules import stock_selection\neligible_stocks = stock_selection.filter(data)\n</code></pre> <p>With <code>data</code> containing the volume per stock per day.</p>"},{"location":"how-to-guides/#how-to-build-a-portfolio","title":"How To Build a Portfolio?","text":"<p>Run the following code</p> <pre><code>from fico.modules import portfolio_build\nportfolios = portfolio_build.build_portfolio(\n    pins,\n    eligible_stocks,\n)\n</code></pre> <p><code>pins</code> means the result of the PIN estimation and <code>eligible_stocks</code> means the result of the stock selection.</p>"},{"location":"how-to-guides/#how-to-measure-returns","title":"How To Measure Returns?","text":"<p>Run: <pre><code>from fico.modules import returns\nr = returns.calculate_all_portfolios_returns(weights, prices)\n</code></pre> <code>weights</code> means the weight of an asset in the portfolio, and <code>prices</code> means the prices of the stocks in time series.</p>"},{"location":"reference/","title":"Reference","text":"<p>Reference for the technical implementation of the <code>PIN</code> project code.</p>"},{"location":"reference/#stock-selection","title":"Stock Selection","text":"<p>Provide 4 stock filters:</p> <pre><code>- Company's most traded stock filter\n- Minimum average volume filter\n- Minimum listed time filter\n- Logical AND of the three filters above\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.filter","title":"filter","text":"<pre><code>filter(volumes)\n</code></pre> <p>Apply Asset Filter</p> <p>Eligibility criteria used by the Center for Financial Economics Research (NEFIN) at the Faculty of Economics, Administration, Accounting, and Actuarial Sciences of the University of S\u00e3o Paulo (FEA - USP).</p> <p>A stock traded on B3 will be eligible in a period if it meets the following three criteria: 1. It is the most traded stock of the company in the previous period. 2. The stock has an average daily trading volume of R$ 500,000 in the previous period. 3. The stock has been listed for at least 2 years from the observation moment.</p> <p>:param volumes: Financial volumes traded for assets</p> <p>:return: Binary dataframe indicating whether a particular asset is eligible for a specific period</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def filter(volumes):\n    '''\n    Apply Asset Filter\n\n    Eligibility criteria used by the Center for Financial Economics Research (NEFIN) at the Faculty of Economics, Administration, Accounting, and Actuarial Sciences of the University of S\u00e3o Paulo (FEA - USP).\n\n    A stock traded on B3 will be eligible in a period if it meets the following three criteria:\n    1. It is the most traded stock of the company in the previous period.\n    2. The stock has an average daily trading volume of R$ 500,000 in the previous period.\n    3. The stock has been listed for at least 2 years from the observation moment.\n\n\n    :param volumes: Financial volumes traded for assets\n\n    :return: Binary dataframe indicating whether a particular asset is eligible for a specific period\n    '''\n\n    mtsf = most_traded_stock_filter(volumes)\n    mvf = minimum_volume_filter(volumes)\n    mltf = minimum_listed_time_filter(volumes)\n\n    eligible_stocks = mtsf &amp; mvf &amp; mltf\n    return eligible_stocks\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.get_first_trading_day","title":"get_first_trading_day","text":"<pre><code>get_first_trading_day(volumes)\n</code></pre> <p>Helper function for minimum_listed_time_filter. Finds the first trading day of the stock</p> <p>:param volumes: Financial volumes traded for assets of one company</p> <p>:return: Date of the first trading day</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def get_first_trading_day(volumes: pd.Series):\n    '''\n    Helper function for minimum_listed_time_filter. Finds the first trading day of the stock\n\n\n    :param volumes: Financial volumes traded for assets of one company\n\n    :return: Date of the first trading day\n    '''\n    trading_dates = volumes.dropna().index\n    return trading_dates[0] if len(trading_dates) &gt; 0 else None\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.minimum_listed_time_filter","title":"minimum_listed_time_filter","text":"<pre><code>minimum_listed_time_filter(volumes, period='M', limit=500)\n</code></pre> <p>Listing time filter. Checks if stocks meet the minimum listing time requirement</p> <p>:param volumes: Financial volumes traded for assets of one company</p> <p>:param period: filtering period. Default='M', meaning monthly</p> <p>:param limit: Minimum required limit. Default=500, meaning 500 business days or 2 years</p> <p>:return: Binary dataframe indicating whether a particular asset is eligible for a specific period</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def minimum_listed_time_filter(volumes, period='M', limit=500):\n    '''\n    Listing time filter. Checks if stocks meet the minimum listing time requirement\n\n\n    :param volumes: Financial volumes traded for assets of one company\n\n    :param period: filtering period. Default='M', meaning monthly\n\n    :param limit: Minimum required limit. Default=500, meaning 500 business days or 2 years\n\n    :return: Binary dataframe indicating whether a particular asset is eligible for a specific period\n    '''\n    result = pd.DataFrame(columns=volumes.columns, index=volumes.index)\n    for stock in volumes.columns:\n        first_trading_day = get_first_trading_day(volumes[stock])\n        if first_trading_day:\n            first_eligible_day = first_trading_day + dt.timedelta(days=limit)\n        else:\n            first_eligible_day = dt.datetime(2200, 1, 1)\n        result[stock] = pd.Series(volumes[stock].index &gt; first_eligible_day, index=volumes[stock].index)\n\n    result = result.resample(period).apply(all)\n    return result\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.minimum_volume_filter","title":"minimum_volume_filter","text":"<pre><code>minimum_volume_filter(volumes, period='M', limit=500000.0)\n</code></pre> <p>Minimum volume filter. Checks if stocks meet the required average volume limit</p> <p>:param volumes: Financial volumes traded for assets of one company</p> <p>:param period: filtering period. Default='M', meaning monthly</p> <p>:param limit: Minimum required limit. Default=5e5, meaning 500,000</p> <p>:return: Binary dataframe indicating whether a particular asset is eligible for a specific period</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def minimum_volume_filter(volumes, period='M', limit=5e5):\n    '''\n    Minimum volume filter. Checks if stocks meet the required average volume limit\n\n\n    :param volumes: Financial volumes traded for assets of one company\n\n    :param period: filtering period. Default='M', meaning monthly\n\n    :param limit: Minimum required limit. Default=5e5, meaning 500,000\n\n    :return: Binary dataframe indicating whether a particular asset is eligible for a specific period\n    '''\n    return volumes.resample(period).mean() &gt;= limit\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.most_traded_per_period","title":"most_traded_per_period","text":"<pre><code>most_traded_per_period(volumes)\n</code></pre> <p>Helper function for most_traded_stock_filter, checks which stock has the highest liquidity</p> <p>:param volumes: Financial volumes traded for assets of one company</p> <p>:return: Binary dataframe indicating whether a particular asset is eligible for a specific period</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def most_traded_per_period(volumes):\n    '''\n    Helper function for most_traded_stock_filter, checks which stock has the highest liquidity\n\n\n    :param volumes: Financial volumes traded for assets of one company\n\n    :return: Binary dataframe indicating whether a particular asset is eligible for a specific period\n    '''\n    result = pd.DataFrame(index=volumes.index, columns=volumes.columns, dtype=bool)\n    for date in volumes.index:\n        if volumes.loc[date].isna().all():\n            result.loc[date] = [False for _ in range(len(volumes.loc[date]))]\n        else:\n            result.loc[date] = volumes.loc[date] == volumes.loc[date].max()\n    return result\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.most_traded_stock_filter","title":"most_traded_stock_filter","text":"<pre><code>most_traded_stock_filter(volumes, period='M')\n</code></pre> <p>Selects the most traded stock of the company in the previous period.</p> <p>:param volumes: Financial volumes traded for assets</p> <p>:param period: filtering period. Default='M', meaning monthly</p> <p>:return: Binary dataframe indicating whether a particular asset is eligible for a specific period</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def most_traded_stock_filter(volumes, period='M'):\n    '''\n    Selects the most traded stock of the company in the previous period.\n\n\n    :param volumes: Financial volumes traded for assets\n\n    :param period: filtering period. Default='M', meaning monthly\n\n    :return: Binary dataframe indicating whether a particular asset is eligible for a specific period\n    '''\n    stocks = stocks_per_firm(volumes.columns)\n    volumes_periodically = volumes.resample(period).sum()\n    result = pd.DataFrame(index=volumes_periodically.index, dtype=bool)\n    for firm in stocks.keys():\n        if len(stocks[firm]) == 1:\n            mtpp = pd.Series([True for _ in result.index], index=result.index, name=stocks[firm][0])\n        else:\n            mtpp = most_traded_per_period(volumes_periodically[stocks[firm]])\n\n        result = pd.concat([result, mtpp], axis=1)\n    return result\n</code></pre>"},{"location":"reference/#fico.modules.stock_selection.stocks_per_firm","title":"stocks_per_firm","text":"<pre><code>stocks_per_firm(stock_list)\n</code></pre> <p>Helper function for most_traded_stock_filter, grouping stocks by company</p> <p>:param stock_list: list of stocks</p> <p>:return: Dictionary with the B3 company code as the key and lists of stocks as values</p> Source code in <code>fico/modules/stock_selection.py</code> <pre><code>def stocks_per_firm(stock_list):\n    '''\n    Helper function for most_traded_stock_filter, grouping stocks by company\n\n\n    :param stock_list: list of stocks\n\n    :return: Dictionary with the B3 company code as the key and lists of stocks as values\n    '''\n    firm_dict = dict()\n    for stock in stock_list:\n        if stock[0:4] not in firm_dict.keys():\n            firm_dict[stock[0:4]] = list()\n        firm_dict[stock[0:4]].append(stock)\n    return firm_dict\n</code></pre>"},{"location":"reference/#pin-estimation","title":"PIN Estimation","text":"<p>Provides the Probability of Insider Trading (PIN) estimation according to Easley et al. (1996)</p>"},{"location":"reference/#fico.modules.pin_estimation.estimate_all_pins","title":"estimate_all_pins","text":"<pre><code>estimate_all_pins(data, window=60, verbose=False)\n</code></pre> <p>Calculate PIN in a rolling window for all data</p> <p>:param data: pd.DataFrame with symbol (ticker), <code>comprador</code>, and <code>vendedor</code></p> <p>:param window: integer indicating the window size (default = 60)</p> <p>:param verbose: if True, it enables prints during the execution</p> <p>:return:</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def estimate_all_pins(data, window=60, verbose=False):\n    '''\n    Calculate PIN in a rolling window for all data\n\n\n    :param data: pd.DataFrame with symbol (ticker), `comprador`, and `vendedor`\n\n    :param window: integer indicating the window size (default = 60)\n\n    :param verbose: if True, it enables prints during the execution\n\n    :return:\n    '''\n    pin_params = pd.DataFrame()\n    grouped_data = data.groupby(by='symbol')\n    for stock in grouped_data.groups.keys():\n        if verbose:\n            print(stock)\n        group = grouped_data.get_group(stock)\n        pin_params = pd.concat([pin_params, rolling_pin(group.sort_index(), window)], ignore_index=True)\n    return pin_params\n</code></pre>"},{"location":"reference/#fico.modules.pin_estimation.estimate_params","title":"estimate_params","text":"<pre><code>estimate_params(data, iterations=10)\n</code></pre> <p>Estimate PIN params:</p> <pre><code>alpha = Probability of the occurrence of an informational event\n\ndelta = Conditional probability of an event with a positive signal\n\nmu = Informed agents flux\n\neps_s = Uninformed agents selling flux\n\neps_b = Uninformed agents buying flux\n</code></pre> <p>:param data: pd.DataFrame with time series for the estimation</p> <p>:param iterations: number of maximum-likelihoods to calculate, to get the highest likelihood</p> <p>:return: params for the highest likelihood</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def estimate_params(data, iterations=10):\n    '''\n    Estimate PIN params:\n\n        alpha = Probability of the occurrence of an informational event\n\n        delta = Conditional probability of an event with a positive signal\n\n        mu = Informed agents flux\n\n        eps_s = Uninformed agents selling flux\n\n        eps_b = Uninformed agents buying flux\n\n\n    :param data: pd.DataFrame with time series for the estimation\n\n    :param iterations: number of maximum-likelihoods to calculate, to get the highest likelihood\n\n    :return: params for the highest likelihood\n    '''\n    avg = data['comprador'].mean()\n    bounds = (\n        (0, 1),\n        (None, None),\n        (0, 1),\n        (None, None),\n        (None, None),\n    )\n\n    while iterations &gt; 0:\n        iterations -= 1\n        initial_params = [np.random.rand(), avg * np.random.rand(), np.random.rand(), avg * np.random.rand(),\n                          avg * np.random.rand()]\n\n        results = minimize(poisson_likelihood, initial_params,\n                           args=(data['comprador'].values, data['vendedor'].values),\n                           bounds=bounds)\n        all_likelihoods.append(iteration_likelihood)\n    params = get_highest_likelihood_params()\n    return params\n</code></pre>"},{"location":"reference/#fico.modules.pin_estimation.get_highest_likelihood_params","title":"get_highest_likelihood_params","text":"<pre><code>get_highest_likelihood_params()\n</code></pre> <p>Select the highest likelihood</p> <p>:return estimations with highest likelihood:</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def get_highest_likelihood_params():\n    '''\n    Select the highest likelihood\n\n\n    :return estimations with highest likelihood:\n    '''\n    global all_likelihoods\n    result_params = {'likelihood': -np.inf}\n    for params in all_likelihoods:\n        if params['likelihood'] &gt; result_params['likelihood']:\n            result_params = params\n    result_params.pop('likelihood')\n    all_likelihoods = list()\n    return result_params\n</code></pre>"},{"location":"reference/#fico.modules.pin_estimation.pin_equation","title":"pin_equation","text":"<pre><code>pin_equation(params)\n</code></pre> <p>PIN equation, according to Easley &amp; O'Hara (1996)</p> <p>:param params: pd.DataFrame with the params alpha, mu, eps_b, and eps_s</p> <p>:return: float number representing the PIN estimation</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def pin_equation(params):\n    '''\n    PIN equation, according to Easley &amp; O'Hara (1996)\n\n\n    :param params: pd.DataFrame with the params alpha, mu, eps_b, and eps_s\n\n    :return: float number representing the PIN estimation\n    '''\n    \u03b1 = params['alpha']\n    \u00b5 = params['mu']\n    \u03b5b = params['eps_b']\n    \u03b5s = params['eps_s']\n\n    return (\u03b1 * \u00b5) / (\u03b1 * \u00b5 + \u03b5b + \u03b5s)\n</code></pre>"},{"location":"reference/#fico.modules.pin_estimation.poisson_likelihood","title":"poisson_likelihood","text":"<pre><code>poisson_likelihood(params, buyers, sellers)\n</code></pre> <p>Estimate the likelihood of the Poisson Mass Function, as described by Easley &amp; O'Hara (1996)</p> <p>:param params: \u03b8 = (alpha, mu, delta, eps_b, eps_s)</p> <p>:param buyers: buying flux series</p> <p>:param sellers: selling flux series</p> <p>:return: negative value of likelihood</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def poisson_likelihood(params, buyers, sellers):\n    '''\n    Estimate the likelihood of the Poisson Mass Function, as described by Easley &amp; O'Hara (1996)\n\n\n    :param params: \u03b8 = (alpha, mu, delta, eps_b, eps_s)\n\n    :param buyers: buying flux series\n\n    :param sellers: selling flux series\n\n    :return: negative value of likelihood\n    '''\n\n    probability_mass_function = poisson.pmf\n    (alpha, mu, delta, eps_b, eps_s) = params\n\n    # Poisson without the occurrence of an informational event (Pn)\n    Pn_buy = probability_mass_function(buyers, eps_b)\n    Pn_sell = probability_mass_function(sellers, eps_s)\n    P_nothing = (1 - alpha) * Pn_buy * Pn_sell\n\n    # Poisson with the occurrence of a positive signal informational event (P_plus)\n    P_plus_buy = probability_mass_function(buyers, eps_b + mu)\n    P_plus = alpha * delta * P_plus_buy * Pn_sell\n\n    # Poisson with the occurrence of a negative signal informational event (P_minus)\n    P_minus_sell = probability_mass_function(sellers, eps_s + mu)\n    P_minus = alpha * (1 - delta) * Pn_buy * P_minus_sell\n    likelihood = -np.sum(P_nothing + P_plus + P_minus)\n\n    global iteration_likelihood\n    iteration_likelihood = {\n        'alpha': alpha,\n        'mu': mu,\n        'delta': delta,\n        'eps_b': eps_b,\n        'eps_s': eps_s,\n        'likelihood': likelihood\n    }\n    return likelihood\n</code></pre>"},{"location":"reference/#fico.modules.pin_estimation.rolling_pin","title":"rolling_pin","text":"<pre><code>rolling_pin(data, window=60)\n</code></pre> <p>Estimate PIN in a rolling window for a time series</p> <p>:param data: pd.DataFrame time series with <code>comprador</code> and <code>vendedor</code></p> <p>:param window: integer indicating the window size (default = 60)</p> <p>:return: pd.DataFrame containing PIN and the estimated params</p> Source code in <code>fico/modules/pin_estimation.py</code> <pre><code>def rolling_pin(data, window=60):\n    '''\n    Estimate PIN in a rolling window for a time series\n\n\n    :param data: pd.DataFrame time series with `comprador` and `vendedor`\n\n    :param window: integer indicating the window size (default = 60)\n\n    :return: pd.DataFrame containing PIN and the estimated params\n    '''\n    data.sort_index(inplace=True)\n    results = list()\n    for i in range(window, data.shape[0]):\n        params = {\n            'symbol': data['symbol'].iloc[i],\n            'period': data['bucket'].iloc[i],\n        }\n        frame = data.iloc[i:window + i]\n        estimated_params = estimate_params(frame)\n        try:\n            params['pin'] = pin_equation(estimated_params)\n        except KeyError:\n            continue\n        params.update(estimated_params)\n        results.append(params)\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"reference/#portfolio-build","title":"Portfolio Build","text":"<p>Provides the portfolio building based on PIN and delta (signal probability) estimations.</p>"},{"location":"reference/#fico.modules.portfolio_build.build_portfolio","title":"build_portfolio","text":"<pre><code>build_portfolio(\n    pin_model,\n    eligible_stocks,\n    pin_quantile=0.75,\n    delta_quantile=0.8,\n    weight_sum_limit=1,\n    leverage=True,\n    fixed_income_weight=1,\n)\n</code></pre> <p>Builds portfolios based on PINs and eligible stocks. If leverage is enabled, it creates a short portfolio.</p> <p>For long and long-only portfolios, stocks are selected based on the highest PINs and deltas. The short portfolio selects stocks based on the highest PINs and lowest deltas. The leveraged long portfolio allocates a percentage of <code>fixed_income_weight</code> to the SELIC.</p> <p>:param pin_model: Results from the previously executed PIN model.</p> <p>:param eligible_stocks: Binary dataframe indicating eligible stocks.</p> <p>:param pin_quantile: Quantile used as a minimum for stock selection based on PIN.</p> <p>:param delta_quantile: Quantile used as a minimum for stock selection based on Delta. (1 - delta_quantile) is used for the short portfolio. :param weight_sum_limit: Total weight of the portfolio.</p> <p>:param leverage: Leverage flag.</p> <p>:param fixed_income_weight: Percentage allocated to SELIC in case of leverage.</p> <p>:return: Dictionary containing 2 sub-dictionaries: one with weights of selected assets and one with their PINs.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def build_portfolio(pin_model, eligible_stocks, pin_quantile=0.75, delta_quantile=0.8, weight_sum_limit=1,\n                    leverage=True, fixed_income_weight=1):\n    \"\"\"\n    Builds portfolios based on PINs and eligible stocks. If leverage is enabled, it creates a short portfolio.\n\n    For long and long-only portfolios, stocks are selected based on the highest PINs and deltas.\n    The short portfolio selects stocks based on the highest PINs and lowest deltas.\n    The leveraged long portfolio allocates a percentage of `fixed_income_weight` to the SELIC.\n\n\n    :param pin_model: Results from the previously executed PIN model.\n\n    :param eligible_stocks: Binary dataframe indicating eligible stocks.\n\n    :param pin_quantile: Quantile used as a minimum for stock selection based on PIN.\n\n    :param delta_quantile: Quantile used as a minimum for stock selection based on Delta.\n    (1 - delta_quantile) is used for the short portfolio.\n    :param weight_sum_limit: Total weight of the portfolio.\n\n    :param leverage: Leverage flag.\n\n    :param fixed_income_weight: Percentage allocated to SELIC in case of leverage.\n\n    :return: Dictionary containing 2 sub-dictionaries: one with weights of selected assets and one with their PINs.\n    \"\"\"\n    dates = get_unique_dates(pin_model['period'])\n    long_portfolio_pin = pd.DataFrame()\n    short_portfolio_pin = pd.DataFrame()\n\n    for date in eligible_stocks.index:\n        if not eligible_stocks.loc[date].any():\n            continue\n        if date &lt; dates[0]:\n            continue\n        if date &gt; dt.datetime.now():\n            continue\n        pins = get_pins(pin_model, eligible_stocks, date)\n        long, short = select_asset_by_delta(pins, q=delta_quantile)\n        long = select_asset_by_pin(long, q=pin_quantile)\n        short = select_asset_by_pin(short, q=pin_quantile)\n\n        long_portfolio_pin = pd.concat([long_portfolio_pin, long], axis=0)\n\n        if leverage:\n            short_portfolio_pin = pd.concat([short_portfolio_pin, short], axis=0)\n\n        long_weights = get_portfolio_weights(long_portfolio_pin, weight_sum_limit, leverage, fixed_income_weight)\n        short_weights = get_portfolio_weights(short_portfolio_pin, fixed_income_weight, leverage=False,\n                                              fixed_income_weight=0)\n        longonly_weights = get_portfolio_weights(long_portfolio_pin, weight_sum_limit=1, leverage=False,\n                                                 fixed_income_weight=0)\n        portfolios = {\n            'pins': {\n                'long': long_portfolio_pin,\n                'short': short_portfolio_pin,\n            },\n            'weights': {\n                'long': long_weights,\n                'short': short_weights,\n                'longonly': longonly_weights,\n            }\n        }\n    return portfolios\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.get_pins","title":"get_pins","text":"<pre><code>get_pins(pin_model, eligible_stocks, date)\n</code></pre> <p>Retrieves the PINs of eligible stocks for a specific date.</p> <p>:param pin_model: Results from the previously executed PIN model.</p> <p>:param eligible_stocks: Binary dataframe indicating eligible stocks.</p> <p>:param date: Reference date.</p> <p>:return: Dataframe of PINs and other estimators (such as delta).</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def get_pins(pin_model, eligible_stocks, date):\n    \"\"\"\n    Retrieves the PINs of eligible stocks for a specific date.\n\n\n    :param pin_model: Results from the previously executed PIN model.\n\n    :param eligible_stocks: Binary dataframe indicating eligible stocks.\n\n    :param date: Reference date.\n\n    :return: Dataframe of PINs and other estimators (such as delta).\n    \"\"\"\n    eligible_stocks_on_date = eligible_stocks.loc[date]\n    stocks = eligible_stocks_on_date[eligible_stocks_on_date].index\n    pins = get_pins_per_date(pin_model, date)\n    pins = pins[pins['symbol'].isin(stocks)].copy()\n    return pins\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.get_pins_per_date","title":"get_pins_per_date","text":"<pre><code>get_pins_per_date(pin_model, date)\n</code></pre> <p>Selects the value of the reference PIN for a date.</p> <p>:param pin_model: Results from the previously executed PIN model.</p> <p>:param date: Reference date.</p> <p>:return: Dataframe of PINs and other estimators (such as delta).</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def get_pins_per_date(pin_model, date):\n    \"\"\"\n    Selects the value of the reference PIN for a date.\n\n\n    :param pin_model: Results from the previously executed PIN model.\n\n    :param date: Reference date.\n\n    :return: Dataframe of PINs and other estimators (such as delta).\n    \"\"\"\n    date_found = False\n    first_date = pin_model['period'].min()\n    pin_on_date = None\n    while not date_found and date &gt;= first_date:\n        pin_on_date = pin_model[pin_model['period'] == date]\n        if pin_on_date.shape[0] &gt; 0:\n            date_found = True\n        else:\n            date = date - dt.timedelta(days=1)\n    return pin_on_date\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.get_portfolio_weights","title":"get_portfolio_weights","text":"<pre><code>get_portfolio_weights(\n    portfolio,\n    weight_sum_limit=1,\n    leverage=True,\n    fixed_income_weight=1,\n)\n</code></pre> <p>Calculates weights for portfolios.</p> <p>:param portfolio: Dictionary of selected stocks.</p> <p>:param weight_sum_limit: Maximum portfolio weight without leverage.</p> <p>:param leverage: Leverage flag.</p> <p>:param fixed_income_weight: Weight allocated to SELIC.</p> <p>:return: Portfolio weights.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def get_portfolio_weights(portfolio, weight_sum_limit=1, leverage=True, fixed_income_weight=1):\n    \"\"\"\n    Calculates weights for portfolios.\n\n\n    :param portfolio: Dictionary of selected stocks.\n\n    :param weight_sum_limit: Maximum portfolio weight without leverage.\n\n    :param leverage: Leverage flag.\n\n    :param fixed_income_weight: Weight allocated to SELIC.\n\n    :return: Portfolio weights.\n    \"\"\"\n    portfolio_weights = dict()\n    port_per_period = portfolio.groupby('period')\n    for period in port_per_period.groups.keys():\n        p = port_per_period.get_group(period)\n        weights = get_weights(p, weight_sum_limit=weight_sum_limit)\n        if leverage:\n            weights['SELIC'] = fixed_income_weight\n        portfolio_weights[period] = weights\n    return portfolio_weights\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.get_unique_dates","title":"get_unique_dates","text":"<pre><code>get_unique_dates(dates)\n</code></pre> <p>Removes duplicates from the collection. :param dates: Collection of dates. :return: List of sorted and unique dates.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def get_unique_dates(dates):\n    \"\"\"\n    Removes duplicates from the collection.\n    :param dates: Collection of dates.\n    :return: List of sorted and unique dates.\n    \"\"\"\n    unique_dates = list(set(dates))\n    unique_dates.sort()\n    return unique_dates\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.get_weights","title":"get_weights","text":"<pre><code>get_weights(portfolio, method='equal', weight_sum_limit=1)\n</code></pre> <p>Calculates weights for a single date. Currently, weights are distributed using the equal method.</p> <p>:param portfolio: Selected stocks for the portfolio.</p> <p>:param method: Weight distribution method. Currently, only equal.</p> <p>:param weight_sum_limit: Maximum portfolio weight.</p> <p>:return: Weights.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def get_weights(portfolio, method='equal', weight_sum_limit=1):\n    \"\"\"\n    Calculates weights for a single date. Currently, weights are distributed using the equal method.\n\n\n    :param portfolio: Selected stocks for the portfolio.\n\n    :param method: Weight distribution method. Currently, only equal.\n\n    :param weight_sum_limit: Maximum portfolio weight.\n\n    :return: Weights.\n    \"\"\"\n    weights = dict()\n    n = portfolio.shape[0]\n    if method == 'equal':\n        weights = {\n            stock: 1 / n * weight_sum_limit\n            for stock in portfolio['symbol']\n        }\n    return weights\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.select_asset_by_delta","title":"select_asset_by_delta","text":"<pre><code>select_asset_by_delta(pins, q)\n</code></pre> <p>Selects assets with deltas outside the [lower, upper] range defined by quantiles q and 1-q.</p> <p>:param pins: Results from the PIN model for a specific date.</p> <p>:param q: Quantile.</p> <p>:return: Selected assets for long and short portfolios.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def select_asset_by_delta(pins, q):\n    \"\"\"\n    Selects assets with deltas outside the [lower, upper] range defined by quantiles q and 1-q.\n\n\n    :param pins: Results from the PIN model for a specific date.\n\n    :param q: Quantile.\n\n    :return: Selected assets for long and short portfolios.\n    \"\"\"\n    delta_inf = np.quantile(pins['delta'], q=1 - q)\n    delta_sup = np.quantile(pins['delta'], q=q)\n    long = pins[pins['delta'] &gt; delta_sup].copy()\n    short = pins[pins['delta'] &lt; delta_inf].copy()\n\n    return long, short\n</code></pre>"},{"location":"reference/#fico.modules.portfolio_build.select_asset_by_pin","title":"select_asset_by_pin","text":"<pre><code>select_asset_by_pin(pins, q)\n</code></pre> <p>Selects assets with PIN above the threshold defined by quantile q.</p> <p>:param pins: Results from the PIN model for a specific date.</p> <p>:param q: Quantile.</p> <p>:return: Selected assets.</p> Source code in <code>fico/modules/portfolio_build.py</code> <pre><code>def select_asset_by_pin(pins, q):\n    \"\"\"\n    Selects assets with PIN above the threshold defined by quantile q.\n\n\n    :param pins: Results from the PIN model for a specific date.\n\n    :param q: Quantile.\n\n    :return: Selected assets.\n    \"\"\"\n    lim = np.quantile(pins['pin'], q=q)\n    result = pins[pins['pin'] &gt; lim].copy()\n    return result\n</code></pre>"},{"location":"reference/#returns","title":"Returns","text":""},{"location":"reference/#fico.modules.returns.calculate_all_portfolios_returns","title":"calculate_all_portfolios_returns","text":"<pre><code>calculate_all_portfolios_returns(\n    portfolios_weights, prices, leverage=True\n)\n</code></pre> <p>Calculate returns for all generated portfolios :param portfolios_weights: Portfolio weights :param prices: Price data :param leverage: Whether to calculate leveraged returns :return: DataFrame with portfolio returns</p> Source code in <code>fico/modules/returns.py</code> <pre><code>def calculate_all_portfolios_returns(portfolios_weights, prices, leverage=True):\n    '''\n    Calculate returns for all generated portfolios\n    :param portfolios_weights: Portfolio weights\n    :param prices: Price data\n    :param leverage: Whether to calculate leveraged returns\n    :return: DataFrame with portfolio returns\n    '''\n    returns = prices.pct_change()\n    all_returns = {\n        portfolio_name: calculate_portfolio_returns(weights, returns)\n        for portfolio_name, weights in portfolios_weights.items()\n    }\n    if leverage:\n        all_returns['long_short'] = all_returns['long'] - all_returns['short']\n    return pd.DataFrame(all_returns)\n</code></pre>"},{"location":"reference/#fico.modules.returns.calculate_portfolio_returns","title":"calculate_portfolio_returns","text":"<pre><code>calculate_portfolio_returns(portfolio_weights, returns)\n</code></pre> <p>Calculate returns for a single portfolio :param portfolio_weights: Portfolio weights :param returns: Returns data :return: Series with portfolio returns</p> Source code in <code>fico/modules/returns.py</code> <pre><code>def calculate_portfolio_returns(portfolio_weights, returns):\n    '''\n    Calculate returns for a single portfolio\n    :param portfolio_weights: Portfolio weights\n    :param returns: Returns data\n    :return: Series with portfolio returns\n    '''\n    first_date = min(portfolio_weights.keys())\n    selic = get_selic(first_date, dt.datetime.now())\n    dates = pd.Series(portfolio_weights.keys(), index=portfolio_weights.keys())\n    portfolio_returns = dict()\n    for date in returns.index:\n        if date &lt;= first_date:\n            continue\n        portfolio = get_portfolio(portfolio_weights, dates, date)\n        stocks_returns = get_stocks_returns(portfolio, returns.loc[date], selic.loc[date])\n        portfolio_returns[date] = stocks_returns\n    return pd.Series(portfolio_returns)\n</code></pre>"},{"location":"reference/#fico.modules.returns.get_portfolio","title":"get_portfolio","text":"<pre><code>get_portfolio(portfolio_weights, dates, date)\n</code></pre> <p>Retrieve a portfolio for a specific date :param portfolio_weights: Portfolio weights :param dates: Dates associated with portfolio weights :param date: Date for which to retrieve the portfolio :return: Portfolio weights for the specified date</p> Source code in <code>fico/modules/returns.py</code> <pre><code>def get_portfolio(portfolio_weights, dates, date):\n    '''\n    Retrieve a portfolio for a specific date\n    :param portfolio_weights: Portfolio weights\n    :param dates: Dates associated with portfolio weights\n    :param date: Date for which to retrieve the portfolio\n    :return: Portfolio weights for the specified date\n    '''\n    i = dates.index.get_indexer([date], method='pad')[0]\n    if date == dates.index[i]:\n        # Portfolio assembled only at the closing\n        date -= dt.timedelta(days=1)\n        i = dates.index.get_indexer([date], method='pad')[0]\n    target_date = dates.index[i]\n    return portfolio_weights[target_date]\n</code></pre>"},{"location":"reference/#fico.modules.returns.get_selic","title":"get_selic","text":"<pre><code>get_selic(start, end)\n</code></pre> <p>Retrieve daily SELIC values :param start: Start date :param end: End date :return: SELIC data</p> Source code in <code>fico/modules/returns.py</code> <pre><code>def get_selic(start, end):\n    '''\n    Retrieve daily SELIC values\n    :param start: Start date\n    :param end: End date\n    :return: SELIC data\n    '''\n    str_start = start.strftime('%d/%m/%Y')\n    str_end = end.strftime('%d/%m/%Y')\n    url = \"http://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=\" + str_start + \"&amp;dataFinal=\" + str_end\n    selic = pd.read_csv(url, sep=\";\", decimal=',')\n    selic.index = [dt.datetime.strptime(date, '%d/%m/%Y') for date in selic['data']]\n    selic['valor'] = selic['valor'] / 100\n    return selic['valor']\n</code></pre>"},{"location":"reference/#fico.modules.returns.get_stocks_returns","title":"get_stocks_returns","text":"<pre><code>get_stocks_returns(portfolio, returns, selic)\n</code></pre> <p>Calculate stock returns :param portfolio: Portfolio weights :param returns: Stock returns :param selic: SELIC returns :return: Portfolio returns</p> Source code in <code>fico/modules/returns.py</code> <pre><code>def get_stocks_returns(portfolio, returns, selic):\n    '''\n    Calculate stock returns\n    :param portfolio: Portfolio weights\n    :param returns: Stock returns\n    :param selic: SELIC returns\n    :return: Portfolio returns\n    '''\n    stocks_returns = 0\n    for stock in portfolio.keys():\n        weight = portfolio[stock]\n        if stock == 'SELIC':\n            r = selic\n        else:\n            r = returns[stock] if pd.notna(returns[stock]) else 0\n        stocks_returns += r * weight\n    return stocks_returns\n</code></pre>"},{"location":"reference/#dataset","title":"Dataset","text":"<p>Provide the required data for the project development</p>"},{"location":"reference/#fico.modules.dataset.load_cedro_quotes","title":"load_cedro_quotes","text":"<pre><code>load_cedro_quotes(path='./fico/data/cedro_data')\n</code></pre> <p>Load quotations from Cedro (B3) Returns: DataFrame with all quotes available</p> Source code in <code>fico/modules/dataset.py</code> <pre><code>def load_cedro_quotes(path='./fico/data/cedro_data'):\n    '''\n    Load quotations from Cedro (B3)\n    Returns: DataFrame with all quotes available\n    '''\n    params = pd.DataFrame()\n    for file in os.listdir(path):\n        if file.endswith('.csv'):\n            data = pd.read_csv(f'{path}/{file}', index_col=0)\n            params = pd.concat([params, data], ignore_index=True)\n    params['bucket'] = str_dates_to_dates(params['bucket'])\n    return params\n</code></pre>"},{"location":"tutorials/","title":"Getting Started","text":"<p>If you do not have <code>poetry</code> installed, execute:</p> <p><code>pip install poetry</code> or <code>python -m pip install poetry</code></p> <p>and than on the project root, to install the necessary dependencies, run:</p> <p><code>poetry install</code>.</p>"},{"location":"tutorials/#workflow","title":"Workflow","text":""},{"location":"tutorials/#imports-and-pin-estimation","title":"Imports and PIN estimation","text":"<p>You may use <code>tutorial.ipynb</code> to start understanding the workflow.  Its first cell will have the modules importation for the first part of the workflow, which is the PIN Estimation.</p> <pre><code>import pandas as pd\n\nfrom fico.modules import dataset\nfrom fico.modules import pin_estimation\n</code></pre> <p>In sequence it will load quotes from the database and store them in 'quotes'  <code>quotes = dataset.load_cedro_quotes()</code>. And now you will be able to estimate PINs by running <code>pins = pin_estimation.estimate_all_pins(quotes, window=60, verbose=True)</code>. The entire process use to last 3 hours long, so if you rather have a small sample of the stocks, just set <code>filter = True</code> and select the stocks you wish to estimate.</p> <p><pre><code>filter = False\nif filter:\n    stocks = {'PETR4', 'VALE3', 'MGLU3'}\n    quotes = quotes[quotes['symbol'].isin(stocks)].copy()\n</code></pre> In addition, there is a full PIN sample stored to save you time in the getting started process. Therefore you may set <code>estimate_all_pins = False</code> and let the code fetch the pre-estimated PINs.</p> <pre><code>estimate_all_pins = False\nif estimate_all_pins:\n    pins = pin_estimation.estimate_all_pins(quotes, window=60, verbose=True)\nelse:\n    pins = dataset.load_results()['pin_results']\npins.sample(5)\n</code></pre>"},{"location":"tutorials/#stock-selection-and-portfolio-build","title":"Stock Selection and Portfolio Build","text":"<p>For this second part, you shall import the necessary modules and load essential data.</p> <p><pre><code>from fico.modules import stock_selection\nfrom fico.modules import portfolio_build\n\neco_data = dataset.load_economatica_quotes()\n</code></pre> Then run the filter you wish to use to set the eligible stocks. That being found, now you are able to build your portfolio:</p> <pre><code>eligible_stocks = stock_selection.filter(eco_data['volumes'])\nportfolios = portfolio_build.build_portfolio(\n    pins,\n    eligible_stocks,\n)\nportfolios\n</code></pre> <p><code>portfolio_build.build_portfolio</code> will return a dictionary containing a timestamp as key (time of the portfolio creation, which will be valid in the next day) and another dictionary as values -- which contains a stock as key and the weight on the portfolio as value. </p> <p>It will be used to calculate returns. <pre><code>from fico.modules import returns\nr = returns.calculate_all_portfolios_returns(portfolios['weights'], eco_data['closing_prices'])\n</code></pre></p> <p>Since the target portfolio is long &amp; short according to the article, so calculate_all_portfolios_returns returns a dataframe with: long (leveraged), short, longonly, and long_short portfolios returns.</p>"}]}